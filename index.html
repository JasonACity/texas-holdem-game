<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ - Texas Hold'em</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        /* è®¾ç½®é¢æ¿ */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        
        .setup-screen h1 {
            text-align: center;
            color: #ffd700;
            margin-bottom: 30px;
            font-size: 1.8rem;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }
        
        .setup-group {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .setup-group h3 {
            color: #ffd700;
            font-size: 1rem;
            margin-bottom: 12px;
        }
        
        .setup-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .setup-item {
            flex: 1;
        }
        
        .setup-item label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .setup-item input, .setup-item select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 1rem;
        }
        
        .ai-config-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .ai-config-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0,0,0,0.2);
            padding: 10px 12px;
            border-radius: 8px;
        }
        
        .ai-config-item span {
            font-size: 0.9rem;
        }
        
        .ai-config-item select {
            padding: 8px 12px;
            border-radius: 6px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 0.85rem;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c73e54);
            color: #fff;
            width: 100%;
            margin-top: 20px;
        }
        
        .btn-primary:active {
            transform: scale(0.98);
        }
        
        /* æ¸¸æˆæ¡Œ */
        .game-table {
            display: none;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }
        
        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0,0,0,0.5);
        }
        
        .pot-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .pot-label {
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .pot-amount {
            font-size: 1.3rem;
            color: #ffd700;
            font-weight: bold;
        }
        
        .stage-badge {
            background: rgba(255,255,255,0.1);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }
        
        /* æ‰‘å…‹æ¡ŒåŒºåŸŸ */
        .table-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        
        /* å¯¹æ‰‹åŒºåŸŸ - é¡¶éƒ¨ */
        .opponents-area {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            padding: 10px 0;
        }
        
        .opponent-seat {
            background: rgba(0,0,0,0.6);
            border-radius: 12px;
            padding: 8px 10px;
            min-width: 70px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .opponent-seat.active {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }
        
        .opponent-seat.folded {
            opacity: 0.4;
        }
        
        .opponent-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            margin: 0 auto 5px;
            font-weight: bold;
        }
        
        .opponent-name {
            font-size: 0.7rem;
            margin-bottom: 2px;
        }
        
        .opponent-type {
            font-size: 0.6rem;
            color: #aaa;
            margin-bottom: 3px;
        }
        
        .opponent-chips {
            font-size: 0.75rem;
            color: #ffd700;
        }
        
        .opponent-bet {
            font-size: 0.65rem;
            color: #e94560;
            margin-top: 2px;
        }
        
        .opponent-cards {
            display: flex;
            gap: 3px;
            justify-content: center;
            margin-top: 5px;
        }
        
        .opponent-cards .card {
            width: 28px;
            height: 40px;
            font-size: 0.7rem;
        }
        
        /* å…¬å…±ç‰ŒåŒºåŸŸ - ä¸­é—´ */
        .community-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #2d5a3d 0%, #1a3d2a 70%, #0d2920 100%);
            border-radius: 50%;
            margin: 10px 20px;
            border: 3px solid #3d2817;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        }
        
        .community-cards {
            display: flex;
            gap: 6px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        /* ç©å®¶åŒºåŸŸ - åº•éƒ¨ */
        .player-area {
            background: rgba(0,0,0,0.7);
            border-radius: 20px 20px 0 0;
            padding: 15px;
            border-top: 2px solid rgba(255,215,0,0.3);
        }
        
        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .player-details h3 {
            font-size: 1rem;
            margin-bottom: 3px;
        }
        
        .player-chips {
            color: #ffd700;
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .hand-strength {
            background: rgba(255,215,0,0.1);
            border: 1px solid rgba(255,215,0,0.3);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            text-align: center;
        }
        
        .hand-strength .win-rate {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffd700;
        }
        
        .position-badge {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            margin-left: 8px;
        }
        
        .player-cards {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        /* æ‰‘å…‹ç‰Œ */
        .card {
            width: 60px;
            height: 84px;
            background: #fff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 3px 15px rgba(0,0,0,0.4);
            border: 1px solid #ddd;
            font-size: 1.2rem;
            animation: dealCard 0.3s ease-out;
        }
        
        @keyframes dealCard {
            from {
                transform: translateY(-50px) rotateY(90deg);
                opacity: 0;
            }
            to {
                transform: translateY(0) rotateY(0);
                opacity: 1;
            }
        }
        
        .card.red { color: #e94560; }
        .card.black { color: #333; }
        
        .card-back {
            background: linear-gradient(135deg, #1a237e, #0d1642);
            border: 2px solid #ffd700;
        }
        
        .card-back::after {
            content: "â™ ";
            font-size: 2rem;
            color: rgba(255,215,0,0.3);
        }
        
        /* æ“ä½œæŒ‰é’® */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .action-btn {
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .action-btn:active {
            transform: scale(0.95);
        }
        
        .btn-fold { background: #666; }
        .btn-check { background: #4a90d9; }
        .btn-call { background: #f5a623; }
        .btn-raise { background: #e94560; grid-column: span 2; }
        .btn-allin { background: #9013fe; }
        
        /* æ¸¸æˆæ—¥å¿— */
        .game-log {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.95);
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.8rem;
            display: none;
            z-index: 100;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        /* åŠ¨ç”»æ•ˆæœ */
        .thinking {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* è·èƒœæ•ˆæœ */
        .winner {
            border-color: #ffd700 !important;
            background: rgba(255,215,0,0.2) !important;
        }
        
        /* æç¤ºä¿¡æ¯ */
        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.1rem;
            z-index: 1001;
            display: none;
        }
    </style>
</head>
<body>
    <!-- è®¾ç½®ç•Œé¢ -->
    <div class="setup-screen" id="setupScreen">
        <h1>ğŸƒ å¾·å·æ‰‘å…‹</h1>
        
        <div class="setup-group">
            <h3>ğŸ’° æ¸¸æˆè®¾ç½®</h3>
            <div class="setup-row">
                <div class="setup-item">
                    <label>åˆå§‹ç­¹ç </label>
                    <input type="number" id="startingChips" value="1000" min="100" step="100">
                </div>
                <div class="setup-item">
                    <label>å°ç›²/å¤§ç›²</label>
                    <input type="text" id="blinds" value="10/20" onchange="updateBlinds()">
                </div>
            </div>
        </div>
        
        <div class="setup-group">
            <h3>ğŸ¤– AIç©å®¶è®¾ç½®</h3>
            <div class="setup-row">
                <div class="setup-item">
                    <label>AIæ•°é‡</label>
                    <select id="aiCount" onchange="updateAIList()">
                        <option value="3">3äºº</option>
                        <option value="4" selected>4äºº</option>
                        <option value="5">5äºº</option>
                    </select>
                </div>
            </div>
            <div class="ai-config-list" id="aiConfigList">
                <!-- AIé…ç½®åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
        
        <button class="btn btn-primary" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
    </div>
    
    <!-- æ¸¸æˆç•Œé¢ -->
    <div class="game-table" id="gameTable">
        <!-- é¡¶éƒ¨ä¿¡æ¯ -->
        <div class="top-bar">
            <div class="pot-info">
                <span class="pot-label">åº•æ± </span>
                <span class="pot-amount" id="potAmount">$0</span>
            </div>
            <div class="stage-badge" id="stageBadge">ç­‰å¾…å¼€å§‹</div>
        </div>
        
        <!-- å¯¹æ‰‹åŒºåŸŸ -->
        <div class="opponents-area" id="opponentsArea">
            <!-- å¯¹æ‰‹åŠ¨æ€ç”Ÿæˆ -->
        </div>
        
        <!-- å…¬å…±ç‰ŒåŒºåŸŸ -->
        <div class="community-area">
            <div class="community-cards" id="communityCards">
                <!-- å…¬å…±ç‰ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
        
        <!-- ç©å®¶åŒºåŸŸ -->
        <div class="player-area" id="playerArea">
            <div class="player-info">
                <div class="player-details">
                    <h3>ä½  <span class="position-badge" id="playerPosition">BTN</span></h3>
                    <div class="player-chips" id="playerChips">$1000</div>
                </div>
                <div class="hand-strength" id="handStrength">
                    <div>-</div>
                    <div class="win-rate" id="winRate"></div>
                </div>
            </div>
            <div class="player-cards" id="playerCards">
                <!-- ç©å®¶æ‰‹ç‰Œ -->
            </div>
            <div class="action-buttons" id="actionButtons" style="display: none;">
                <button class="action-btn btn-fold" onclick="playerAction('fold')">å¼ƒç‰Œ</button>
                <button class="action-btn btn-check" id="btnCheck" onclick="playerAction('check')">è¿‡ç‰Œ</button>
                <button class="action-btn btn-call" id="btnCall" onclick="playerAction('call')">è·Ÿæ³¨</button>
                <button class="action-btn btn-raise" onclick="playerAction('raise')">åŠ æ³¨</button>
                <button class="action-btn btn-allin" onclick="playerAction('allin')">å…¨ä¸‹</button>
            </div>
        </div>
    </div>
    
    <!-- æ¸¸æˆæ—¥å¿— -->
    <div class="game-log" id="gameLog"></div>
    
    <!-- æç¤º -->
    <div class="toast" id="toast"></div>

    <script>
        // ==================== æ¸¸æˆå¸¸é‡ ====================
        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
        
        const AI_TYPES = {
            TAG: { name: 'ç´§å‡¶', color: '#4CAF50', vpip: 0.18, pfr: 0.15, aggression: 2.5 },
            LAG: { name: 'æ¾å‡¶', color: '#f44336', vpip: 0.35, pfr: 0.28, aggression: 3.0 },
            TP: { name: 'ç´§å¼±', color: '#2196F3', vpip: 0.12, pfr: 0.06, aggression: 1.2 },
            LP: { name: 'æ¾å¼±', color: '#FF9800', vpip: 0.40, pfr: 0.08, aggression: 0.8 }
        };
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let game = {
            players: [],
            deck: [],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            stage: 'preflop',
            activeIndex: 0,
            dealerIndex: 0,
            sb: 10,
            bb: 20
        };
        
        // ==================== åˆå§‹åŒ– ====================
        function updateBlinds() {
            const blindsInput = document.getElementById('blinds');
            if (!blindsInput) return;
            const parts = blindsInput.value.split('/');
            if (parts.length === 2) {
                game.sb = parseInt(parts[0]) || 10;
                game.bb = parseInt(parts[1]) || 20;
            }
        }
        
        function updateAIList() {
            const countSelect = document.getElementById('aiCount');
            if (!countSelect) return;
            const count = parseInt(countSelect.value);
            const container = document.getElementById('aiConfigList');
            if (!container) return;
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'ai-config-item';
                div.innerHTML = `
                    <span>AI ${i + 1}</span>
                    <select id="aiType${i}">
                        <option value="TAG">ç´§å‡¶å‹</option>
                        <option value="LAG" selected>æ¾å‡¶å‹</option>
                        <option value="TP">ç´§å¼±å‹</option>
                        <option value="LP">æ¾å¼±å‹</option>
                    </select>
                `;
                container.appendChild(div);
            }
        }
        
        // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updateAIList();
                updateBlinds();
            });
        } else {
            updateAIList();
            updateBlinds();
        }
        
        // ==================== å¡ç‰Œç³»ç»Ÿ ====================
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (let i = 0; i < RANKS.length; i++) {
                    deck.push({ suit, rank: RANKS[i], value: i });
                }
            }
            // æ´—ç‰Œ
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }
        
        function deal() {
            return game.deck.pop();
        }
        
        // ==================== å¼€å§‹æ¸¸æˆ ====================
        function startGame() {
            const startingChips = parseInt(document.getElementById('startingChips').value);
            const aiCount = parseInt(document.getElementById('aiCount').value);
            
            // åˆ›å»ºç©å®¶
            game.players = [{
                id: 0, name: 'ä½ ', isHuman: true,
                chips: startingChips, cards: [],
                bet: 0, folded: false, allIn: false
            }];
            
            for (let i = 0; i < aiCount; i++) {
                const type = document.getElementById(`aiType${i}`).value;
                game.players.push({
                    id: i + 1, name: `AI${i + 1}`, type,
                    isHuman: false, chips: startingChips,
                    cards: [], bet: 0, folded: false, allIn: false
                });
            }
            
            // éšæœºåº„å®¶
            game.dealerIndex = Math.floor(Math.random() * game.players.length);
            
            // åˆ‡æ¢ç•Œé¢
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameTable').style.display = 'flex';
            
            newHand();
        }
        
        // ==================== æ–°ä¸€å±€ ====================
        function newHand() {
            // é‡ç½®çŠ¶æ€
            game.deck = createDeck();
            game.communityCards = [];
            game.pot = 0;
            game.currentBet = 0;
            game.stage = 'preflop';
            
            // æ¸…é™¤æ˜¾ç¤ºç¼“å­˜
            lastHandCards = '';
            lastCommunityCards = '';
            document.getElementById('communityCards').innerHTML = '';
            document.getElementById('playerCards').innerHTML = '';
            
            game.players.forEach(p => {
                p.cards = [];
                p.bet = 0;
                p.folded = false;
                p.allIn = false;
            });
            
            // å‘æ‰‹ç‰Œ
            for (let i = 0; i < 2; i++) {
                game.players.forEach(p => p.cards.push(deal()));
            }
            
            // ç›²æ³¨
            const sbIndex = (game.dealerIndex + 1) % game.players.length;
            const bbIndex = (game.dealerIndex + 2) % game.players.length;
            placeBet(game.players[sbIndex], game.sb);
            placeBet(game.players[bbIndex], game.bb);
            game.currentBet = game.bb;
            
            // ä»UTGå¼€å§‹
            game.activeIndex = (bbIndex + 1) % game.players.length;
            
            showToast('æ–°ä¸€å±€å¼€å§‹');
            updateDisplay();
            nextTurn();
        }
        
        function placeBet(player, amount) {
            const actual = Math.min(amount, player.chips);
            player.chips -= actual;
            player.bet += actual;
            game.pot += actual;
            if (player.chips === 0) player.allIn = true;
        }
        
        // ==================== æ˜¾ç¤ºæ›´æ–° ====================
        let lastHandCards = '';
        let lastCommunityCards = '';
        
        function getPositionName(index) {
            const pos = (index - game.dealerIndex + game.players.length) % game.players.length;
            const names = ['BTN', 'SB', 'BB', 'UTG', 'MP', 'CO'];
            return names[pos] || 'MP';
        }
        
        function calculateWinRate(hole, community) {
            if (hole.length !== 2) return 0;
            
            // ç®€åŒ–èƒœç‡è®¡ç®—ï¼šåŸºäºæ‰‹ç‰Œå¼ºåº¦å’Œå…¬å…±ç‰ŒåŒ¹é…åº¦
            const all = [...hole, ...community];
            const ranks = all.map(c => c.value);
            const suits = all.map(c => c.suit);
            
            // åŸºç¡€èƒœç‡
            let winRate = 0;
            
            // å¯¹å­æ½œåŠ›
            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            const maxCount = Math.max(...Object.values(rankCounts));
            
            if (maxCount >= 4) winRate = 95;
            else if (maxCount === 3 && Object.values(rankCounts).filter(c => c === 2).length > 0) winRate = 85;
            else if (maxCount === 3) winRate = 70;
            else if (Object.values(rankCounts).filter(c => c === 2).length >= 2) winRate = 60;
            else if (maxCount === 2) winRate = 45;
            else {
                // é«˜ç‰Œèƒœç‡
                const highCard = Math.max(...hole.map(c => c.value));
                winRate = (highCard / 12) * 35;
            }
            
            // åŒèŠ±å¬ç‰ŒåŠ æˆ
            const suitCounts = {};
            suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const maxSuit = Math.max(...Object.values(suitCounts));
            if (maxSuit >= 5) winRate += 20;
            else if (maxSuit === 4 && community.length < 5) winRate += 10;
            
            // é¡ºå­å¬ç‰ŒåŠ æˆï¼ˆç®€åŒ–ï¼‰
            const uniqueRanks = [...new Set(ranks)].sort((a, b) => a - b);
            let maxConnected = 1;
            let current = 1;
            for (let i = 1; i < uniqueRanks.length; i++) {
                if (uniqueRanks[i] - uniqueRanks[i-1] === 1) {
                    current++;
                    maxConnected = Math.max(maxConnected, current);
                } else {
                    current = 1;
                }
            }
            if (maxConnected >= 5) winRate += 15;
            else if (maxConnected === 4 && community.length < 5) winRate += 8;
            
            return Math.min(Math.round(winRate), 99);
        }
        
        function updateDisplay() {
            // æ›´æ–°åº•æ± å’Œé˜¶æ®µ
            document.getElementById('potAmount').textContent = `$${game.pot}`;
            const stageNames = { preflop: 'ç¿»ç‰Œå‰', flop: 'ç¿»ç‰Œ', turn: 'è½¬ç‰Œ', river: 'æ²³ç‰Œ', showdown: 'æ‘Šç‰Œ' };
            document.getElementById('stageBadge').textContent = stageNames[game.stage] || game.stage;
            
            // æ›´æ–°ç©å®¶ä½ç½®
            const humanIndex = game.players.findIndex(p => p.isHuman);
            document.getElementById('playerPosition').textContent = getPositionName(humanIndex);
            
            // æ›´æ–°å¯¹æ‰‹
            const opponentsArea = document.getElementById('opponentsArea');
            opponentsArea.innerHTML = '';
            game.players.forEach((p, i) => {
                if (p.isHuman) return;
                const seat = document.createElement('div');
                seat.className = `opponent-seat ${i === game.activeIndex ? 'active' : ''} ${p.folded ? 'folded' : ''}`;
                const typeInfo = AI_TYPES[p.type] || {};
                const posName = getPositionName(i);
                seat.innerHTML = `
                    <div class="opponent-avatar" style="background: ${typeInfo.color || '#666'}">${posName}</div>
                    <div class="opponent-name">${p.name}</div>
                    <div class="opponent-type">${typeInfo.name || ''}</div>
                    <div class="opponent-chips">$${p.chips}</div>
                    ${p.bet > 0 ? `<div class="opponent-bet">$${p.bet}</div>` : ''}
                `;
                opponentsArea.appendChild(seat);
            });
            
            // æ›´æ–°å…¬å…±ç‰Œï¼ˆåªæ·»åŠ æ–°ç‰Œï¼Œä¸æ¸…é™¤ï¼‰
            const communityEl = document.getElementById('communityCards');
            const newCommunityKey = JSON.stringify(game.communityCards);
            if (newCommunityKey !== lastCommunityCards) {
                // åªæ¸²æŸ“æ–°å¢çš„ç‰Œ
                const existingCount = communityEl.children.length;
                for (let i = existingCount; i < game.communityCards.length; i++) {
                    const c = game.communityCards[i];
                    const cardDiv = document.createElement('div');
                    cardDiv.className = `card ${c.suit === 'â™¥' || c.suit === 'â™¦' ? 'red' : 'black'}`;
                    cardDiv.textContent = `${c.rank}${c.suit}`;
                    communityEl.appendChild(cardDiv);
                }
                lastCommunityCards = newCommunityKey;
            }
            
            // æ›´æ–°ç©å®¶ä¿¡æ¯
            const human = game.players[0];
            document.getElementById('playerChips').textContent = `$${human.chips}`;
            
            // æ‰‹ç‰Œå’Œèƒœç‡ï¼ˆåªåœ¨å‘ç‰Œæ—¶æ›´æ–°ï¼Œç¿»ç‰Œæ—¶ä¸é‡ç»˜ï¼‰
            const newHandKey = JSON.stringify(human.cards);
            if (newHandKey !== lastHandCards && human.cards.length === 2) {
                const playerCardsEl = document.getElementById('playerCards');
                playerCardsEl.innerHTML = human.cards.map(c => `
                    <div class="card ${c.suit === 'â™¥' || c.suit === 'â™¦' ? 'red' : 'black'}">
                        ${c.rank}${c.suit}
                    </div>
                `).join('');
                lastHandCards = newHandKey;
            }
            
            // å®æ—¶æ›´æ–°èƒœç‡
            if (human.cards.length === 2) {
                const winRate = calculateWinRate(human.cards, game.communityCards);
                const handRank = evaluateHandRank(human.cards, game.communityCards);
                document.getElementById('handStrength').querySelector('div').textContent = handRank;
                document.getElementById('winRate').textContent = `${winRate}%èƒœç‡`;
            }
        }
        
        function evaluateHandRank(hole, community) {
            const all = [...hole, ...community];
            if (all.length < 2) return '-';
            
            const ranks = all.map(c => c.value);
            const suits = all.map(c => c.suit);
            
            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            
            // æ£€æŸ¥åŒèŠ±
            const suitCounts = {};
            suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const hasFlush = Math.max(...Object.values(suitCounts)) >= 5;
            
            // æ£€æŸ¥é¡ºå­
            const uniqueRanks = [...new Set(ranks)].sort((a, b) => a - b);
            let hasStraight = false;
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (uniqueRanks[i+4] - uniqueRanks[i] === 4) hasStraight = true;
            }
            // A-5 é¡ºå­
            if (uniqueRanks.includes(12) && uniqueRanks.includes(0) && 
                uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
                hasStraight = true;
            }
            
            if (hasStraight && hasFlush) return 'åŒèŠ±é¡º';
            if (counts[0] === 4) return 'å››æ¡';
            if (counts[0] === 3 && counts[1] >= 2) return 'è‘«èŠ¦';
            if (hasFlush) return 'åŒèŠ±';
            if (hasStraight) return 'é¡ºå­';
            if (counts[0] === 3) return 'ä¸‰æ¡';
            if (counts[0] === 2 && counts[1] === 2) return 'ä¸¤å¯¹';
            if (counts[0] === 2) return 'ä¸€å¯¹';
            
            const highCard = Math.max(...hole.map(c => c.value));
            return `${RANKS[highCard]}é«˜ç‰Œ`;
        }
                seat.className = `opponent-seat ${i === game.activeIndex ? 'active' : ''} ${p.folded ? 'folded' : ''}`;
                const typeInfo = AI_TYPES[p.type] || {};
                seat.innerHTML = `
                    <div class="opponent-avatar" style="background: ${typeInfo.color || '#666'}">${p.type}</div>
                    <div class="opponent-name">${p.name}</div>
                    <div class="opponent-type">${typeInfo.name || ''}</div>
                    <div class="opponent-chips">$${p.chips}</div>
                    ${p.bet > 0 ? `<div class="opponent-bet">$${p.bet}</div>` : ''}
                `;
                opponentsArea.appendChild(seat);
            });
            
            // æ›´æ–°å…¬å…±ç‰Œï¼ˆå¸¦æ¸…é™¤åŠ¨ç”»ï¼‰
            const communityEl = document.getElementById('communityCards');
            communityEl.innerHTML = game.communityCards.map((c, i) => `
                <div class="card ${c.suit === 'â™¥' || c.suit === 'â™¦' ? 'red' : 'black'}" 
                     style="animation-delay: ${i * 0.1}s">
                    ${c.rank}${c.suit}
                </div>
            `).join('');
            
            // æ›´æ–°ç©å®¶ä¿¡æ¯
            const human = game.players[0];
            document.getElementById('playerChips').textContent = `$${human.chips}`;
            document.getElementById('handStrength').textContent = evaluateHand(human.cards, game.communityCards);
            
            // æ›´æ–°ç©å®¶æ‰‹ç‰Œ
            const playerCardsEl = document.getElementById('playerCards');
            playerCardsEl.innerHTML = human.cards.map(c => `
                <div class="card ${c.suit === 'â™¥' || c.suit === 'â™¦' ? 'red' : 'black'}">
                    ${c.rank}${c.suit}
                </div>
            `).join('');
        }
        
        function evaluateHand(hole, community) {
            const all = [...hole, ...community];
            if (all.length < 2) return '-';
            
            // ç®€åŒ–è¯„ä¼°
            const ranks = all.map(c => c.value);
            const suits = all.map(c => c.suit);
            
            // æ£€æŸ¥å¯¹å­
            const counts = {};
            ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);
            const pairs = Object.values(counts).filter(c => c >= 2).length;
            const trips = Object.values(counts).filter(c => c >= 3).length;
            const quads = Object.values(counts).filter(c => c >= 4).length;
            
            if (quads) return 'å››æ¡';
            if (trips && pairs) return 'è‘«èŠ¦';
            if (Math.max(...Object.values(counts)) >= 5) return 'åŒèŠ±';
            if (pairs >= 2) return 'ä¸¤å¯¹';
            if (pairs) return 'ä¸€å¯¹';
            
            const high = Math.max(...ranks);
            return `${RANKS[high]}é«˜ç‰Œ`;
        }
        
        // ==================== æ¸¸æˆæµç¨‹ ====================
        function nextTurn() {
            const player = game.players[game.activeIndex];
            
            if (player.folded || player.allIn) {
                nextPlayer();
                return;
            }
            
            updateDisplay();
            
            if (player.isHuman) {
                showPlayerActions();
            } else {
                setTimeout(() => aiDecision(player), 1000);
            }
        }
        
        function showPlayerActions() {
            const player = game.players[0];
            const toCall = game.currentBet - player.bet;
            
            document.getElementById('actionButtons').style.display = 'grid';
            document.getElementById('btnCheck').style.display = toCall === 0 ? 'block' : 'none';
            document.getElementById('btnCall').style.display = toCall > 0 ? 'block' : 'none';
            document.getElementById('btnCall').textContent = `è·Ÿæ³¨ $${toCall}`;
        }
        
        function playerAction(action) {
            const player = game.players[0];
            const toCall = game.currentBet - player.bet;
            
            document.getElementById('actionButtons').style.display = 'none';
            
            switch(action) {
                case 'fold':
                    player.folded = true;
                    showToast('ä½ å¼ƒç‰Œäº†');
                    break;
                case 'check':
                    showToast('ä½ è¿‡ç‰Œ');
                    break;
                case 'call':
                    placeBet(player, toCall);
                    showToast(`ä½ è·Ÿæ³¨ $${toCall}`);
                    break;
                case 'raise':
                    const raiseAmt = parseInt(prompt('åŠ æ³¨é‡‘é¢:', game.bb * 3)) || game.bb * 3;
                    placeBet(player, toCall + raiseAmt);
                    game.currentBet = player.bet;
                    showToast(`ä½ åŠ æ³¨åˆ° $${player.bet}`);
                    break;
                case 'allin':
                    placeBet(player, player.chips);
                    game.currentBet = Math.max(game.currentBet, player.bet);
                    showToast('ä½ å…¨ä¸‹äº†ï¼');
                    break;
            }
            
            nextPlayer();
        }
        
        function aiDecision(player) {
            const type = AI_TYPES[player.type];
            const handStr = Math.random();
            const toCall = game.currentBet - player.bet;
            
            let action = 'fold';
            
            if (game.stage === 'preflop') {
                if (Math.random() < type.vpip && handStr > 0.3) {
                    if (Math.random() < type.pfr || game.currentBet === player.bet) {
                        action = 'raise';
                    } else {
                        action = 'call';
                    }
                } else if (game.currentBet === player.bet) {
                    action = 'check';
                }
            } else {
                if (handStr > 0.6) {
                    action = Math.random() < type.aggression / 3 ? 'raise' : 'call';
                } else if (handStr > 0.3 && toCall < game.pot * 0.3) {
                    action = 'call';
                } else if (game.currentBet === player.bet) {
                    action = 'check';
                }
            }
            
            // AIæ€è€ƒæ—¶é—´1ç§’
            setTimeout(() => {
                switch(action) {
                    case 'fold':
                        player.folded = true;
                        showToast(`${player.name} å¼ƒç‰Œ`);
                        break;
                    case 'check':
                        showToast(`${player.name} è¿‡ç‰Œ`);
                        break;
                    case 'call':
                        placeBet(player, toCall);
                        showToast(`${player.name} è·Ÿæ³¨ $${toCall}`);
                        break;
                    case 'raise':
                        const raiseAmt = game.bb * (2 + Math.floor(Math.random() * 3));
                        placeBet(player, toCall + raiseAmt);
                        game.currentBet = player.bet;
                        showToast(`${player.name} åŠ æ³¨åˆ° $${player.bet}`);
                        break;
                }
                nextPlayer();
            }, 1000);
        }
        
        function nextPlayer() {
            // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€äºº
            const active = game.players.filter(p => !p.folded);
            if (active.length === 1) {
                endHand(active[0]);
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦è¯¥è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
            const needToAct = game.players.filter(p => !p.folded && !p.allIn);
            const allActed = needToAct.every(p => p.bet === game.currentBet || p.allIn);
            
            if (allActed && needToAct.length > 0) {
                nextStage();
                return;
            }
            
            // ä¸‹ä¸€ä¸ªç©å®¶
            do {
                game.activeIndex = (game.activeIndex + 1) % game.players.length;
            } while (game.players[game.activeIndex].folded || game.players[game.activeIndex].allIn);
            
            nextTurn();
        }
        
        function nextStage() {
            // æ”¶æ‹¢ä¸‹æ³¨
            game.players.forEach(p => p.bet = 0);
            game.currentBet = 0;
            
            switch(game.stage) {
                case 'preflop':
                    game.stage = 'flop';
                    game.communityCards.push(deal(), deal(), deal());
                    showToast('ç¿»ç‰Œ');
                    break;
                case 'flop':
                    game.stage = 'turn';
                    game.communityCards.push(deal());
                    showToast('è½¬ç‰Œ');
                    break;
                case 'turn':
                    game.stage = 'river';
                    game.communityCards.push(deal());
                    showToast('æ²³ç‰Œ');
                    break;
                case 'river':
                    showdown();
                    return;
            }
            
            game.activeIndex = (game.dealerIndex + 1) % game.players.length;
            while (game.players[game.activeIndex].folded) {
                game.activeIndex = (game.activeIndex + 1) % game.players.length;
            }
            
            updateDisplay();
            nextTurn();
        }
        
        function showdown() {
            game.stage = 'showdown';
            
            // æ˜¾ç¤ºæ‰€æœ‰AIçš„æ‰‹ç‰Œ
            const active = game.players.filter(p => !p.folded);
            active.forEach(p => {
                if (!p.isHuman) {
                    // æ‰¾åˆ°å¯¹åº”çš„å¯¹æ‰‹åº§ä½å¹¶æ˜¾ç¤ºæ‰‹ç‰Œ
                    const seats = document.querySelectorAll('.opponent-seat');
                    seats.forEach(seat => {
                        const nameEl = seat.querySelector('.opponent-name');
                        if (nameEl && nameEl.textContent === p.name) {
                            const cardsDiv = document.createElement('div');
                            cardsDiv.className = 'opponent-cards';
                            cardsDiv.innerHTML = p.cards.map(c => `
                                <div class="card ${c.suit === 'â™¥' || c.suit === 'â™¦' ? 'red' : 'black'}">
                                    ${c.rank}${c.suit}
                                </div>
                            `).join('');
                            seat.appendChild(cardsDiv);
                        }
                    });
                }
            });
            
            updateDisplay();
            
            // è®¡ç®—èµ¢å®¶ï¼ˆåŸºäºå®é™…ç‰ŒåŠ›ï¼‰
            let winner = active[0];
            let bestStrength = -1;
            
            active.forEach(p => {
                const strength = evaluateHandStrength(p.cards, game.communityCards);
                if (strength > bestStrength) {
                    bestStrength = strength;
                    winner = p;
                }
            });
            
            setTimeout(() => {
                winner.chips += game.pot;
                showToast(`ğŸ† ${winner.name} èµ¢å¾— $${game.pot}!`);
                
                // é«˜äº®èµ¢å®¶
                const seats = document.querySelectorAll('.opponent-seat');
                seats.forEach(seat => {
                    const nameEl = seat.querySelector('.opponent-name');
                    if (nameEl && nameEl.textContent === winner.name) {
                        seat.classList.add('winner');
                    }
                });
                
                setTimeout(() => {
                    game.dealerIndex = (game.dealerIndex + 1) % game.players.length;
                    newHand();
                }, 4000);
            }, 1500);
        }
        
        function evaluateHandStrength(hole, community) {
            const all = [...hole, ...community];
            if (all.length < 2) return 0;
            
            const ranks = all.map(c => c.value);
            const suits = all.map(c => c.suit);
            
            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            
            // æ£€æŸ¥åŒèŠ±
            const suitCounts = {};
            suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const hasFlush = Math.max(...Object.values(suitCounts)) >= 5;
            
            // æ£€æŸ¥é¡ºå­
            const uniqueRanks = [...new Set(ranks)].sort((a, b) => a - b);
            let hasStraight = false;
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (uniqueRanks[i+4] - uniqueRanks[i] === 4) hasStraight = true;
            }
            if (uniqueRanks.includes(12) && uniqueRanks.includes(0) && 
                uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
                hasStraight = true;
            }
            
            let strength = 0;
            if (hasStraight && hasFlush) strength = 8000000;
            else if (counts[0] === 4) strength = 7000000 + counts[1] * 100 + Math.max(...ranks);
            else if (counts[0] === 3 && counts[1] >= 2) strength = 6000000 + Math.max(...ranks);
            else if (hasFlush) strength = 5000000 + Math.max(...ranks);
            else if (hasStraight) strength = 4000000 + Math.max(...ranks);
            else if (counts[0] === 3) strength = 3000000 + Math.max(...ranks);
            else if (counts[0] === 2 && counts[1] === 2) strength = 2000000 + Math.max(...ranks);
            else if (counts[0] === 2) strength = 1000000 + Math.max(...ranks);
            else strength = Math.max(...ranks);
            
            return strength;
        }
        
        function endHand(winner) {
            winner.chips += game.pot;
            showToast(`ğŸ† ${winner.name} èµ¢å¾— $${game.pot}!`);
            updateDisplay();
            
            setTimeout(() => {
                game.dealerIndex = (game.dealerIndex + 1) % game.players.length;
                newHand();
            }, 3000);
        }
        
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.style.display = 'block';
            setTimeout(() => toast.style.display = 'none', 2000);
        }
    </script>
</body>
</html>
